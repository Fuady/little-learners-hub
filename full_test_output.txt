============================= test session starts =============================
platform win32 -- Python 3.9.6, pytest-8.4.2, pluggy-1.6.0 -- C:\Program Files\Python39\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\amfua\Documents\GitHub\kid_apps\little-learners-hub\backend
configfile: pyproject.toml
plugins: anyio-4.11.0, langsmith-0.4.37, asyncio-1.2.0
asyncio: mode=auto, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 41 items

backend\tests\test_api.py::TestHealthEndpoints::test_root ERROR          [  2%]
backend\tests\test_api.py::TestHealthEndpoints::test_health ERROR        [  4%]
backend\tests\test_api.py::TestAuthEndpoints::test_login_success ERROR   [  7%]
backend\tests\test_api.py::TestAuthEndpoints::test_login_invalid_credentials ERROR [  9%]
backend\tests\test_api.py::TestAuthEndpoints::test_register_success ERROR [ 12%]
backend\tests\test_api.py::TestAuthEndpoints::test_register_duplicate_email ERROR [ 14%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_list_materials ERROR [ 17%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_list_materials_with_type_filter ERROR [ 19%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_list_materials_with_grade_filter ERROR [ 21%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_list_materials_with_search ERROR [ 24%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_get_material_by_id ERROR [ 26%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_get_material_not_found ERROR [ 29%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_download_material ERROR [ 31%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_like_material_with_auth ERROR [ 34%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_submit_material_as_educator ERROR [ 36%]
backend\tests\test_api.py::TestMaterialsEndpoints::test_submit_material_as_parent_fails ERROR [ 39%]
backend\tests\test_api.py::TestStatsEndpoints::test_get_stats ERROR      [ 41%]
backend\tests\test_api.py::TestUsersEndpoints::test_get_current_user_with_auth ERROR [ 43%]
backend\tests\test_database.py::TestPasswordOperations::test_password_hash_creates_different_hashes PASSED [ 46%]
backend\tests\test_database.py::TestPasswordOperations::test_verify_password_correct PASSED [ 48%]
backend\tests\test_database.py::TestUserOperations::test_create_and_get_user PASSED [ 51%]
backend\tests\test_database.py::TestUserOperations::test_get_user_by_email_nonexistent PASSED [ 53%]
backend\tests\test_database.py::TestMaterialOperations::test_create_and_get_material PASSED [ 56%]
backend\tests\test_database.py::TestMaterialOperations::test_get_materials_filters PASSED [ 58%]
backend\tests\test_database.py::TestMaterialOperations::test_increment_downloads PASSED [ 60%]
backend\tests\test_database.py::TestStatsOperations::test_get_stats PASSED [ 63%]
backend\tests\test_simple.py::test_simple_async PASSED                   [ 65%]
backend\tests\test_workflows.py::TestUserJourney::test_parent_complete_journey FAILED [ 68%]
backend\tests\test_workflows.py::TestUserJourney::test_educator_complete_journey FAILED [ 70%]
backend\tests\test_workflows.py::TestMaterialWorkflow::test_material_discovery_and_download FAILED [ 73%]
backend\tests\test_workflows.py::TestMaterialWorkflow::test_material_engagement_workflow FAILED [ 75%]
backend\tests\test_workflows.py::TestSearchAndFilterWorkflow::test_progressive_filtering FAILED [ 78%]
backend\tests\test_workflows.py::TestSearchAndFilterWorkflow::test_pagination_workflow FAILED [ 80%]
backend\tests\test_workflows.py::TestAuthorizationWorkflow::test_parent_cannot_submit_material FAILED [ 82%]
backend\tests\test_workflows.py::TestAuthorizationWorkflow::test_educator_can_submit_material FAILED [ 85%]
backend\tests\test_workflows.py::TestAuthorizationWorkflow::test_unauthenticated_access FAILED [ 87%]
backend\tests\test_workflows.py::TestErrorRecoveryWorkflow::test_invalid_login_then_valid_login FAILED [ 90%]
backend\tests\test_workflows.py::TestErrorRecoveryWorkflow::test_search_no_results_then_valid_search FAILED [ 92%]
backend\tests\test_workflows.py::TestErrorRecoveryWorkflow::test_invalid_material_id_then_valid_id FAILED [ 95%]
backend\tests\test_workflows.py::TestDataConsistency::test_stats_consistency_after_operations FAILED [ 97%]
backend\tests\test_workflows.py::TestDataConsistency::test_material_count_consistency FAILED [100%]

=================================== ERRORS ====================================
_______________ ERROR at setup of TestHealthEndpoints.test_root _______________

self = <Coroutine test_root>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C23CD340>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
______________ ERROR at setup of TestHealthEndpoints.test_health ______________

self = <Coroutine test_health>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C267AA30>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
___________ ERROR at setup of TestAuthEndpoints.test_login_success ____________

self = <Coroutine test_login_success>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C258C820>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
_____ ERROR at setup of TestAuthEndpoints.test_login_invalid_credentials ______

self = <Coroutine test_login_invalid_credentials>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C2591E80>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
__________ ERROR at setup of TestAuthEndpoints.test_register_success __________

self = <Coroutine test_register_success>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C267A550>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
______ ERROR at setup of TestAuthEndpoints.test_register_duplicate_email ______

self = <Coroutine test_register_duplicate_email>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C268EDC0>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
________ ERROR at setup of TestMaterialsEndpoints.test_list_materials _________

self = <Coroutine test_list_materials>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C26947F0>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
_ ERROR at setup of TestMaterialsEndpoints.test_list_materials_with_type_filter _

self = <Coroutine test_list_materials_with_type_filter>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C267A370>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
_ ERROR at setup of TestMaterialsEndpoints.test_list_materials_with_grade_filter _

self = <Coroutine test_list_materials_with_grade_filter>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C25C2790>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
__ ERROR at setup of TestMaterialsEndpoints.test_list_materials_with_search ___

self = <Coroutine test_list_materials_with_search>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C24E2400>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
______ ERROR at setup of TestMaterialsEndpoints.test_get_material_by_id _______

self = <Coroutine test_get_material_by_id>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C262B160>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
____ ERROR at setup of TestMaterialsEndpoints.test_get_material_not_found _____

self = <Coroutine test_get_material_not_found>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C27680A0>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
_______ ERROR at setup of TestMaterialsEndpoints.test_download_material _______

self = <Coroutine test_download_material>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C263C5E0>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
____ ERROR at setup of TestMaterialsEndpoints.test_like_material_with_auth ____

self = <Coroutine test_like_material_with_auth>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C270DC10>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
__ ERROR at setup of TestMaterialsEndpoints.test_submit_material_as_educator __

self = <Coroutine test_submit_material_as_educator>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C2813220>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
_ ERROR at setup of TestMaterialsEndpoints.test_submit_material_as_parent_fails _

self = <Coroutine test_submit_material_as_parent_fails>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C2716520>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
_____________ ERROR at setup of TestStatsEndpoints.test_get_stats _____________

self = <Coroutine test_get_stats>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C2823A90>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
____ ERROR at setup of TestUsersEndpoints.test_get_current_user_with_auth _____

self = <Coroutine test_get_current_user_with_auth>

    def setup(self) -> None:
        runner_fixture_id = f"_{self._loop_scope}_scoped_runner"
        if runner_fixture_id not in self.fixturenames:
            self.fixturenames.append(runner_fixture_id)
>       return super().setup()

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:748: in pytest_fixture_setup
    hook_result = yield
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:318: in _asyncgen_fixture_wrapper
    result = runner.run(setup(), context=context)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\backports\asyncio\runner\runner.py:175: in run
    return self._loop.run_until_complete(task)  # type: ignore[union-attr, no-any-return]
C:\Program Files\Python39\lib\asyncio\base_events.py:642: in run_until_complete
    return future.result()
C:\Program Files\Python39\lib\asyncio\futures.py:201: in result
    raise self._exception
C:\Program Files\Python39\lib\asyncio\tasks.py:256: in __step
    result = coro.send(None)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\pytest_asyncio\plugin.py:314: in setup
    res = await gen_obj.__anext__()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C2895F40>

    @pytest_asyncio.fixture(scope="function")
    async def client(db_session):
        """Async API client with DB override"""
        async def override_get_db():
            yield db_session
    
        app.dependency_overrides[get_db] = override_get_db
    
        # Use AsyncClient for async endpoints
>       async with AsyncClient(app=app, base_url="http://test") as ac:
E       TypeError: __init__() got an unexpected keyword argument 'app'

backend\tests\conftest.py:59: TypeError
================================== FAILURES ===================================
________________ TestUserJourney.test_parent_complete_journey _________________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C27EC8B0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C27D7B80>
parameters = [('journey_parent@test.com',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: users

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestUserJourney object at 0x000001E2C23BE2B0>

    def test_parent_complete_journey(self):
        """Test parent user: register \u2192 login \u2192 browse \u2192 like \u2192 logout"""
        # Step 1: Register
>       register_response = client.post(
            "/api/v1/auth/register",
            json={
                "email": "journey_parent@test.com",
                "password": "testpass123",
                "name": "Journey Parent",
                "role": "parent",
            },
        )

backend\tests\test_workflows.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:552: in post
    return super().post(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1144: in post
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\auth.py:100: in register
    existing_user = await get_user_by_email(db, user_data.email)
backend\database.py:25: in get_user_by_email
    result = await db.execute(select(User).where(User.email == email))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:449: in execute
    result = await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2351: in execute
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: users
E               [SQL: SELECT users.id, users.email, users.name, users.hashed_password, users.role, users.avatar, users.created_at 
E               FROM users 
E               WHERE users.email = ?]
E               [parameters: ('journey_parent@test.com',)]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
_______________ TestUserJourney.test_educator_complete_journey ________________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C39CFAF0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C27D7B80>
parameters = [('journey_educator@test.com',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: users

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestUserJourney object at 0x000001E2C23BE460>

    def test_educator_complete_journey(self):
        """Test educator: register \u2192 login \u2192 submit material \u2192 verify"""
        # Step 1: Register as educator
>       register_response = client.post(
            "/api/v1/auth/register",
            json={
                "email": "journey_educator@test.com",
                "password": "testpass123",
                "name": "Journey Educator",
                "role": "educator",
            },
        )

backend\tests\test_workflows.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:552: in post
    return super().post(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1144: in post
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\auth.py:100: in register
    existing_user = await get_user_by_email(db, user_data.email)
backend\database.py:25: in get_user_by_email
    result = await db.execute(select(User).where(User.email == email))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:449: in execute
    result = await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2351: in execute
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: users
E               [SQL: SELECT users.id, users.email, users.name, users.hashed_password, users.role, users.avatar, users.created_at 
E               FROM users 
E               WHERE users.email = ?]
E               [parameters: ('journey_educator@test.com',)]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
__________ TestMaterialWorkflow.test_material_discovery_and_download __________

self = <backend.tests.test_workflows.TestMaterialWorkflow object at 0x000001E2C23BE6A0>

    def test_material_discovery_and_download(self):
        """Test: search \u2192 filter \u2192 view \u2192 download"""
        # Step 1: Search for materials
>       search_response = client.get("/api/v1/materials?search=math")

backend\tests\test_workflows.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:479: in get
    return super().get(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1053: in get
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\materials.py:44: in list_materials
    materials_db, total = await get_materials(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C2895F40>
material_type = None, grade_level = None, search = 'math', limit = 50
offset = 0

    async def get_materials(
        db: AsyncSession,
        material_type: Optional[MaterialType] = None,
        grade_level: Optional[GradeLevel] = None,
        search: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> Tuple[List[Material], int]:
        query = select(Material)
    
        if material_type:
            query = query.where(Material.type == material_type.value)
    
        if grade_level:
            query = query.where(Material.grade_level == grade_level.value)
    
        if search:
            search_lower = f"%{search.lower()}%"
            query = query.where(
                or_(
                    func.lower(Material.title).like(search_lower),
                    func.lower(Material.description).like(search_lower),
                    # Search in tags needs JSON logic depending on DB (Postgres vs SQLite)
                    # For compatibility/simplicity, we might skip tag search in SQL or use naive string match if stored as JSON/String
                    # SQLite JSON functions vs Postgres API.
                    # Assuming simple string matching for now or robust logic?
                    # Let's try to match serialized JSON text for simplicity across DBs:
>                   func.cast(Material.tags, String).like(search_lower)
                )
            )
E           NameError: name 'String' is not defined

backend\database.py:86: NameError
___________ TestMaterialWorkflow.test_material_engagement_workflow ____________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C2BE00D0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C27D7B80>
parameters = [('parent@example.com',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: users

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestMaterialWorkflow object at 0x000001E2C23BE850>

    def test_material_engagement_workflow(self):
        """Test: browse \u2192 like \u2192 download \u2192 check stats"""
        # Login as parent
>       login_response = client.post(
            "/api/v1/auth/login",
            json={"email": "parent@example.com", "password": "password123"},
        )

backend\tests\test_workflows.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:552: in post
    return super().post(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1144: in post
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\auth.py:135: in login
    user_in_db = await get_user_by_email(db, login_data.email)
backend\database.py:25: in get_user_by_email
    result = await db.execute(select(User).where(User.email == email))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:449: in execute
    result = await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2351: in execute
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: users
E               [SQL: SELECT users.id, users.email, users.name, users.hashed_password, users.role, users.avatar, users.created_at 
E               FROM users 
E               WHERE users.email = ?]
E               [parameters: ('parent@example.com',)]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
___________ TestSearchAndFilterWorkflow.test_progressive_filtering ____________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C3AABD60>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C3AAB2E0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: materials

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestSearchAndFilterWorkflow object at 0x000001E2C23BEA90>

    def test_progressive_filtering(self):
        """Test: all materials \u2192 filter type \u2192 add grade \u2192 add search"""
        # Step 1: Get all materials
>       all_response = client.get("/api/v1/materials")

backend\tests\test_workflows.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:479: in get
    return super().get(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1053: in get
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\materials.py:44: in list_materials
    materials_db, total = await get_materials(
backend\database.py:92: in get_materials
    total = await db.scalar(count_query) or 0
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:505: in scalar
    return await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2399: in scalar
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: materials
E               [SQL: SELECT count(*) AS count_1 
E               FROM (SELECT materials.id AS id, materials.title AS title, materials.description AS description, materials.type AS type, materials.grade_level AS grade_level, materials.thumbnail AS thumbnail, materials.download_url AS download_url, materials.is_interactive AS is_interactive, materials.author_id AS author_id, materials.author_name AS author_name, materials.created_at AS created_at, materials.downloads AS downloads, materials.likes AS likes, materials.tags AS tags 
E               FROM materials) AS anon_1]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
____________ TestSearchAndFilterWorkflow.test_pagination_workflow _____________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C4D00760>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C3AAB2E0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: materials

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestSearchAndFilterWorkflow object at 0x000001E2C23BEC40>

    def test_pagination_workflow(self):
        """Test: browse first page \u2192 next page \u2192 verify no duplicates"""
        page_size = 3
    
        # Get first page
>       page1_response = client.get(f"/api/v1/materials?limit={page_size}&offset=0")

backend\tests\test_workflows.py:229: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:479: in get
    return super().get(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1053: in get
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\materials.py:44: in list_materials
    materials_db, total = await get_materials(
backend\database.py:92: in get_materials
    total = await db.scalar(count_query) or 0
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:505: in scalar
    return await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2399: in scalar
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: materials
E               [SQL: SELECT count(*) AS count_1 
E               FROM (SELECT materials.id AS id, materials.title AS title, materials.description AS description, materials.type AS type, materials.grade_level AS grade_level, materials.thumbnail AS thumbnail, materials.download_url AS download_url, materials.is_interactive AS is_interactive, materials.author_id AS author_id, materials.author_name AS author_name, materials.created_at AS created_at, materials.downloads AS downloads, materials.likes AS likes, materials.tags AS tags 
E               FROM materials) AS anon_1]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
________ TestAuthorizationWorkflow.test_parent_cannot_submit_material _________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C2A90F70>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C27D7B80>
parameters = [('parent@example.com',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: users

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestAuthorizationWorkflow object at 0x000001E2C23BEE50>

    def test_parent_cannot_submit_material(self):
        """Test that parent role cannot submit materials"""
        # Login as parent
>       login_response = client.post(
            "/api/v1/auth/login",
            json={"email": "parent@example.com", "password": "password123"},
        )

backend\tests\test_workflows.py:255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:552: in post
    return super().post(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1144: in post
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\auth.py:135: in login
    user_in_db = await get_user_by_email(db, login_data.email)
backend\database.py:25: in get_user_by_email
    result = await db.execute(select(User).where(User.email == email))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:449: in execute
    result = await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2351: in execute
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: users
E               [SQL: SELECT users.id, users.email, users.name, users.hashed_password, users.role, users.avatar, users.created_at 
E               FROM users 
E               WHERE users.email = ?]
E               [parameters: ('parent@example.com',)]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
_________ TestAuthorizationWorkflow.test_educator_can_submit_material _________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C2E7A490>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C27D7B80>
parameters = [('teacher@example.com',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: users

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestAuthorizationWorkflow object at 0x000001E2C23CD040>

    def test_educator_can_submit_material(self):
        """Test that educator role can submit materials"""
        # Login as educator
>       login_response = client.post(
            "/api/v1/auth/login",
            json={"email": "teacher@example.com", "password": "password123"},
        )

backend\tests\test_workflows.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:552: in post
    return super().post(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1144: in post
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\auth.py:135: in login
    user_in_db = await get_user_by_email(db, login_data.email)
backend\database.py:25: in get_user_by_email
    result = await db.execute(select(User).where(User.email == email))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:449: in execute
    result = await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2351: in execute
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: users
E               [SQL: SELECT users.id, users.email, users.name, users.hashed_password, users.role, users.avatar, users.created_at 
E               FROM users 
E               WHERE users.email = ?]
E               [parameters: ('teacher@example.com',)]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
____________ TestAuthorizationWorkflow.test_unauthenticated_access ____________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C4C25430>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C3AAB2E0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: materials

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestAuthorizationWorkflow object at 0x000001E2C23CD1F0>

    def test_unauthenticated_access(self):
        """Test that unauthenticated users can browse but not interact"""
        # Can browse materials
>       browse_response = client.get("/api/v1/materials")

backend\tests\test_workflows.py:303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:479: in get
    return super().get(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1053: in get
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\materials.py:44: in list_materials
    materials_db, total = await get_materials(
backend\database.py:92: in get_materials
    total = await db.scalar(count_query) or 0
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:505: in scalar
    return await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2399: in scalar
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: materials
E               [SQL: SELECT count(*) AS count_1 
E               FROM (SELECT materials.id AS id, materials.title AS title, materials.description AS description, materials.type AS type, materials.grade_level AS grade_level, materials.thumbnail AS thumbnail, materials.download_url AS download_url, materials.is_interactive AS is_interactive, materials.author_id AS author_id, materials.author_name AS author_name, materials.created_at AS created_at, materials.downloads AS downloads, materials.likes AS likes, materials.tags AS tags 
E               FROM materials) AS anon_1]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
________ TestErrorRecoveryWorkflow.test_invalid_login_then_valid_login ________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C4C3D880>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C27D7B80>
parameters = [('parent@example.com',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: users

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestErrorRecoveryWorkflow object at 0x000001E2C23CD430>

    def test_invalid_login_then_valid_login(self):
        """Test recovery from failed login attempt"""
        # Attempt with wrong password
>       fail_response = client.post(
            "/api/v1/auth/login",
            json={"email": "parent@example.com", "password": "wrongpassword"},
        )

backend\tests\test_workflows.py:329: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:552: in post
    return super().post(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1144: in post
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\auth.py:135: in login
    user_in_db = await get_user_by_email(db, login_data.email)
backend\database.py:25: in get_user_by_email
    result = await db.execute(select(User).where(User.email == email))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:449: in execute
    result = await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2351: in execute
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: users
E               [SQL: SELECT users.id, users.email, users.name, users.hashed_password, users.role, users.avatar, users.created_at 
E               FROM users 
E               WHERE users.email = ?]
E               [parameters: ('parent@example.com',)]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
_____ TestErrorRecoveryWorkflow.test_search_no_results_then_valid_search ______

self = <backend.tests.test_workflows.TestErrorRecoveryWorkflow object at 0x000001E2C23CD5E0>

    def test_search_no_results_then_valid_search(self):
        """Test recovery from empty search results"""
        # Search with no results
>       empty_response = client.get("/api/v1/materials?search=xyznoresults")

backend\tests\test_workflows.py:346: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:479: in get
    return super().get(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1053: in get
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\materials.py:44: in list_materials
    materials_db, total = await get_materials(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001E2C2895F40>
material_type = None, grade_level = None, search = 'xyznoresults', limit = 50
offset = 0

    async def get_materials(
        db: AsyncSession,
        material_type: Optional[MaterialType] = None,
        grade_level: Optional[GradeLevel] = None,
        search: Optional[str] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> Tuple[List[Material], int]:
        query = select(Material)
    
        if material_type:
            query = query.where(Material.type == material_type.value)
    
        if grade_level:
            query = query.where(Material.grade_level == grade_level.value)
    
        if search:
            search_lower = f"%{search.lower()}%"
            query = query.where(
                or_(
                    func.lower(Material.title).like(search_lower),
                    func.lower(Material.description).like(search_lower),
                    # Search in tags needs JSON logic depending on DB (Postgres vs SQLite)
                    # For compatibility/simplicity, we might skip tag search in SQL or use naive string match if stored as JSON/String
                    # SQLite JSON functions vs Postgres API.
                    # Assuming simple string matching for now or robust logic?
                    # Let's try to match serialized JSON text for simplicity across DBs:
>                   func.cast(Material.tags, String).like(search_lower)
                )
            )
E           NameError: name 'String' is not defined

backend\database.py:86: NameError
______ TestErrorRecoveryWorkflow.test_invalid_material_id_then_valid_id _______

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C2AABFD0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C2E6EB50>
parameters = [('invalid-id-999',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: materials

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestErrorRecoveryWorkflow object at 0x000001E2C23CD790>

    def test_invalid_material_id_then_valid_id(self):
        """Test recovery from invalid material ID"""
        # Try invalid ID
>       invalid_response = client.get("/api/v1/materials/invalid-id-999")

backend\tests\test_workflows.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:479: in get
    return super().get(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1053: in get
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\materials.py:65: in get_material
    material_db = await get_material_by_id(db, material_id)
backend\database.py:103: in get_material_by_id
    return await db.get(Material, material_id)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:592: in get
    return await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:3680: in get
    return self._get_impl(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:3859: in _get_impl
    return db_load_fn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\loading.py:695: in load_on_pk_identity
    session.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2351: in execute
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: materials
E               [SQL: SELECT materials.id AS materials_id, materials.title AS materials_title, materials.description AS materials_description, materials.type AS materials_type, materials.grade_level AS materials_grade_level, materials.thumbnail AS materials_thumbnail, materials.download_url AS materials_download_url, materials.is_interactive AS materials_is_interactive, materials.author_id AS materials_author_id, materials.author_name AS materials_author_name, materials.created_at AS materials_created_at, materials.downloads AS materials_downloads, materials.likes AS materials_likes, materials.tags AS materials_tags 
E               FROM materials 
E               WHERE materials.id = ?]
E               [parameters: ('invalid-id-999',)]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
_________ TestDataConsistency.test_stats_consistency_after_operations _________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C3B08700>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C3B087F0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: materials

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestDataConsistency object at 0x000001E2C23CDA00>

    def test_stats_consistency_after_operations(self):
        """Test that stats remain consistent after various operations"""
        # Get initial stats
>       initial_stats = client.get("/api/v1/stats").json()

backend\tests\test_workflows.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:479: in get
    return super().get(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1053: in get
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\stats.py:18: in get_platform_stats
    stats = await get_stats(db)
backend\database.py:172: in get_stats
    total_materials = await db.scalar(select(func.count(Material.id))) or 0
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:505: in scalar
    return await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2399: in scalar
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: materials
E               [SQL: SELECT count(materials.id) AS count_1 
E               FROM materials]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
_____________ TestDataConsistency.test_material_count_consistency _____________

self = <sqlalchemy.engine.base.Connection object at 0x000001E2C25C2790>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x000001E2C2895E20>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x000001E2C34176A0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001E2C3AAB2E0>
parameters = [()]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlite3.OperationalError: no such table: materials

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError

The above exception was the direct cause of the following exception:

self = <backend.tests.test_workflows.TestDataConsistency object at 0x000001E2C23CDBB0>

    def test_material_count_consistency(self):
        """Test that material counts are consistent across endpoints"""
        # Get total from list endpoint
>       list_response = client.get("/api/v1/materials")

backend\tests\test_workflows.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:479: in get
    return super().get(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1053: in get
    return self.request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:451: in request
    return super().request(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:914: in send
    response = self._send_handling_auth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\httpx\_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:354: in handle_request
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\testclient.py:351: in handle_request
    portal.call(self.app, scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:321: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
C:\Program Files\Python39\lib\concurrent\futures\_base.py:445: in result
    return self.__get_result()
C:\Program Files\Python39\lib\concurrent\futures\_base.py:390: in __get_result
    raise self._exception
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\anyio\from_thread.py:252: in _call_func
    retval = await retval_or_awaitable
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\applications.py:1135: in __call__
    await super().__call__(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\applications.py:113: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:186: in __call__
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\errors.py:164: in __call__
    await self.app(scope, receive, _send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\middleware\exceptions.py:63: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\middleware\asyncexitstack.py:18: in __call__
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:716: in __call__
    await self.middleware_stack(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:736: in app
    await route.handle(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\routing.py:290: in handle
    await self.app(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:115: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:101: in app
    response = await f(request)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:355: in app
    raw_response = await run_endpoint_function(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\fastapi\routing.py:243: in run_endpoint_function
    return await dependant.call(**values)
backend\routers\materials.py:44: in list_materials
    materials_db, total = await get_materials(
backend\database.py:92: in get_materials
    total = await db.scalar(count_query) or 0
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\ext\asyncio\session.py:505: in scalar
    return await greenlet_spawn(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:201: in greenlet_spawn
    result = context.throw(*sys.exc_info())
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2399: in scalar
    return self._execute_internal(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\session.py:2249: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\orm\context.py:306: in orm_execute_statement
    result = conn.execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:160: in _execute
    return await future
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

tx = <_queue.SimpleQueue object at 0x000001E2C2626BD0>

    def _connection_worker_thread(tx: _TxQueue):
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            future, function = tx.get()
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
E               sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: materials
E               [SQL: SELECT count(*) AS count_1 
E               FROM (SELECT materials.id AS id, materials.title AS title, materials.description AS description, materials.type AS type, materials.grade_level AS grade_level, materials.thumbnail AS thumbnail, materials.download_url AS download_url, materials.is_interactive AS is_interactive, materials.author_id AS author_id, materials.author_name AS author_name, materials.created_at AS created_at, materials.downloads AS downloads, materials.likes AS likes, materials.tags AS tags 
E               FROM materials) AS anon_1]
E               (Background on this error at: https://sqlalche.me/e/20/e3q8)

..\..\..\..\AppData\Roaming\Python\Python39\site-packages\aiosqlite\core.py:63: OperationalError
=========================== short test summary info ===========================
FAILED backend\tests\test_workflows.py::TestUserJourney::test_parent_complete_journey
FAILED backend\tests\test_workflows.py::TestUserJourney::test_educator_complete_journey
FAILED backend\tests\test_workflows.py::TestMaterialWorkflow::test_material_discovery_and_download
FAILED backend\tests\test_workflows.py::TestMaterialWorkflow::test_material_engagement_workflow
FAILED backend\tests\test_workflows.py::TestSearchAndFilterWorkflow::test_progressive_filtering
FAILED backend\tests\test_workflows.py::TestSearchAndFilterWorkflow::test_pagination_workflow
FAILED backend\tests\test_workflows.py::TestAuthorizationWorkflow::test_parent_cannot_submit_material
FAILED backend\tests\test_workflows.py::TestAuthorizationWorkflow::test_educator_can_submit_material
FAILED backend\tests\test_workflows.py::TestAuthorizationWorkflow::test_unauthenticated_access
FAILED backend\tests\test_workflows.py::TestErrorRecoveryWorkflow::test_invalid_login_then_valid_login
FAILED backend\tests\test_workflows.py::TestErrorRecoveryWorkflow::test_search_no_results_then_valid_search
FAILED backend\tests\test_workflows.py::TestErrorRecoveryWorkflow::test_invalid_material_id_then_valid_id
FAILED backend\tests\test_workflows.py::TestDataConsistency::test_stats_consistency_after_operations
FAILED backend\tests\test_workflows.py::TestDataConsistency::test_material_count_consistency
ERROR backend\tests\test_api.py::TestHealthEndpoints::test_root - TypeError: ...
ERROR backend\tests\test_api.py::TestHealthEndpoints::test_health - TypeError...
ERROR backend\tests\test_api.py::TestAuthEndpoints::test_login_success - Type...
ERROR backend\tests\test_api.py::TestAuthEndpoints::test_login_invalid_credentials
ERROR backend\tests\test_api.py::TestAuthEndpoints::test_register_success - T...
ERROR backend\tests\test_api.py::TestAuthEndpoints::test_register_duplicate_email
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_list_materials
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_list_materials_with_type_filter
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_list_materials_with_grade_filter
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_list_materials_with_search
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_get_material_by_id
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_get_material_not_found
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_download_material
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_like_material_with_auth
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_submit_material_as_educator
ERROR backend\tests\test_api.py::TestMaterialsEndpoints::test_submit_material_as_parent_fails
ERROR backend\tests\test_api.py::TestStatsEndpoints::test_get_stats - TypeErr...
ERROR backend\tests\test_api.py::TestUsersEndpoints::test_get_current_user_with_auth
================== 14 failed, 9 passed, 18 errors in 15.65s ===================
